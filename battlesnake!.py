# -*- coding: utf-8 -*-
"""battlesnake!.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1olHToJxN-JR_b0pVFOxsuRJ3SnVqAut6
"""
import json
import numpy as np
import sklearn
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
import tensorflow as tf
from keras import layers


# Function to load JSON from a file
def load_game_data(file_path):
    with open(file_path, 'r') as file:
        return json.load(file)

  # Function to extract moves for a specific snake
def extract_moves(game_data, snakeID):
    moves = []

    # Initialize previous head positions for the given snakeID
    previous_positions = {}

    for turn_data in game_data:
        snakes = turn_data.get("Snakes", [])

        for snake in snakes:
            if snake["ID"] == snakeID:
                # Get the current snake's head position
                head_position = snake["Body"][0]
                snake_id = snake["ID"]

                if snake_id not in previous_positions:
                    # Initialize with the first turn's position
                    previous_positions[snake_id] = head_position
                    continue

                # Determine the move based on the change in position
                prev_position = previous_positions[snake_id]
                current_position = head_position

                move = None
                if current_position["X"] > prev_position["X"]:
                    move = "right"
                elif current_position["X"] < prev_position["X"]:
                    move = "left"
                elif current_position["Y"] > prev_position["Y"]:
                    move = "down"
                elif current_position["Y"] < prev_position["Y"]:
                    move = "up"

                # Store the move along with the turn number
                moves.append({
                    "Turn": turn_data["Turn"],
                    "SnakeID": snake_id,
                    "Move": move
                })

                # Update previous position
                previous_positions[snake_id] = current_position

    return moves

# File path to the JSON data
file_path = 'frames.json'  # Replace with your file path
author = 'coreyja'  # Author to track

# Load the game data from the file
game_data = load_game_data(file_path)

# Extract moves for the specified author
moves = extract_moves(game_data, author)

# Function to load JSON from a file
def load_game_data(file_path):
    with open(file_path, 'r') as file:
        return json.load(file)

# Function to preprocess the game state
def preprocess_game_data(game_data, snakeID):
    X_train = []

    for game_state in game_data:
        turn = game_state["Turn"]
        food = game_state["Food"]
        snakes = game_state["Snakes"]

        # Initialize lists for player and enemy snakes
        player_body = None
        enemy_bodies = []

        for snake in snakes:
            # # Skip dead snakes
            # if snake.get("Death") is not None:
            #     continue

            snake_body = [(s["X"], s["Y"]) for s in snake["Body"]]
            if snake["ID"] == snakeID:
                player_body = snake_body
            else:
                enemy_bodies.append(snake_body)

        if player_body is None:
            continue  # Skip if the player's snake is not found

        # Flatten features into a vector (simple representation)
        features = {
            "turn": turn,
            "food_positions": [(f["X"], f["Y"]) for f in food],
            "player_body": player_body,
            "enemy_bodies": enemy_bodies
        }
        X_train.append(features)

    return X_train

# Example function to vectorize the data for machine learning
def vectorize_data(X_train):
    # Convert to a format suitable for a model (e.g., flatten features, use one-hot encoding for moves)
    # For now, we just return X_train as is (modify depending on the model)
    return X_train

# Load the JSON data from the file
file_path = 'frames.json'  # Replace with your file path
snakeID = 'gs_kyDB7QyKYDKVjKxQRjj7mG4M'
game_data = load_game_data(file_path)
moves = extract_moves(game_data, snakeID)

# Preprocess the game data
preprocessed_game_data = preprocess_game_data(game_data, snakeID)[:-1]

# Vectorize data for training
vectorized_game_data = vectorize_data(preprocessed_game_data)

# Example output (you can modify how you store or use this)
# print("Training Data Features:", vectorized_game_data)
# print("Training Labels:", moves)


def preprocess_state(state):
    # Convert the board into a flattened array
    board_size = 11  # for an 11x11 board
    grid = np.zeros((board_size, board_size))

    # Mark snake body positions as -1
    for segment in state['player_body']:
        grid[segment[0], segment[1]] = -1

    # Mark food position as 1
    for food in state['food_positions']:
        grid[food[0], food[1]] = 1

    # Mark opponent snakes
    for opponent in state['enemy_bodies']:
        for segment in opponent:
            grid[segment[0], segment[1]] = -2

    # Flatten the grid
    return grid.flatten()


# Collect your features (X) and actions (y)
X = []  # Preprocessed board states
y = []  # Corresponding actions (up, down, left, right)

# Assume data has been collected and preprocessed
for i, data_point in enumerate(vectorized_game_data):
    X.append(preprocess_state(data_point))
    y.append(moves[i]['Move'])

# Convert actions to numerical labels (up: 0, down: 1, left: 2, right: 3)
action_map = {'up': 0, 'down': 1, 'left': 2, 'right': 3}
y = [action_map[action] for action in y]

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

# Train a Decision Tree Classifier
model = DecisionTreeClassifier()
model.fit(X_train, y_train)

# Evaluate the model
accuracy = model.score(X_test, y_test)
print(f"Model accuracy: {accuracy}")


# Function to flatten features (example implementation)
def flatten_features(features):
    # Flatten the features into a vector (this is just an example, adjust as needed)
    # turn = features["turn"]
    # # print(features["turn"])
    food_positions = [coord for f in features["food_positions"] for coord in f]
    player_body = [coord for s in features["player_body"] for coord in s]
    enemy_bodies = [coord for b in features["enemy_bodies"][0] for coord in b]
     # Define the desired length for padding
    desired_length = 1000

    # Function to pad arrays to the desired length
    def pad_to_length(arr, length):
        return np.pad(arr, (0, max(0, length - len(arr))), mode='constant')

    # Pad each feature array to the desired length
    # turn_padded = pad_to_length(turn, desired_length)
    food_positions_padded = pad_to_length(food_positions, desired_length)
    player_body_padded = pad_to_length(player_body, desired_length)
    enemy_bodies_padded = pad_to_length(enemy_bodies, desired_length)

    # Concatenate all arrays
    return np.concatenate([food_positions_padded, player_body_padded, enemy_bodies_padded])

# Function to convert labels to indices (example implementation)
def label_to_index(label):
    move_map = {"up": 0, "down": 1, "left": 2, "right": 3}
    return move_map.get(label, -1)

# Function to convert features and labels into NumPy arrays
def convert_to_numpy(X, y):
    # Flatten the feature dictionaries into a NumPy array
    X_array = np.array([flatten_features(x) for x in X])
    # Convert labels to a NumPy array
    y_array = np.array([label_to_index(label) for label in y])
    return X_array, y_array

X_train = preprocess_game_data(game_data, snakeID)[:-1]
y_train = [action["Move"] for action in moves]

X_array, y_array = convert_to_numpy(X_train, y_train)

# Ensure the shape is correct
# print(f"Features shape: {X_array.shape}")
# print(f"Labels shape: {y_array.shape}")

# Standardize features
scaler = sklearn.preprocessing.StandardScaler()
X_array = scaler.fit_transform(X_array)

# Define a simple neural network model
model = tf.keras.Sequential([
    layers.Dense(64, activation='relu', input_shape=(X_array.shape[1],)),
    layers.Dense(32, activation='relu'),
    layers.Dense(4, activation='softmax')  # Assuming 4 possible moves: up, down, left, right
])

# # Neural network model
# model = tf.keras.Sequential([
#     layers.InputLayer(input_shape=(len(X[0]),)),
#     layers.Dense(128, activation='relu'),
#     layers.Dense(64, activation='relu'),
#     layers.Dense(4, activation='softmax')  # 4 possible moves
# ])

model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# # print(X_array)
# # print(y_array)

# Train the model
model.fit(X_array, y_array, epochs=10, validation_split=0.2)

# Evaluate the model
loss, accuracy = model.evaluate(X_array, y_array)
# print(f"Test accuracy: {accuracy}")

def predict_direction(model_output):
    # Assuming model_output is a probability distribution over possible directions
    directions = ["up", "down", "left", "right"]  # or whatever actions your model predicts
    direction_index = np.argmax(model_output)
    return directions[direction_index]

# File path to the JSON data
test_file_path = 'frames1.json'  # Replace with your file path
test_snakeID = 'gs_VRhvKcHgfgv64PQDJpSgQfpC'  # snakeID to track

# Load the game data from the file
test_game_data = load_game_data(test_file_path)

test_moves = extract_moves(test_game_data, test_snakeID)

X_test = preprocess_game_data(test_game_data, test_snakeID)
X_test = np.array([flatten_features(x) for x in X_test])

scaler = sklearn.preprocessing.StandardScaler()
X_test = scaler.fit_transform(X_test)

move_num = 220

model_output = model.predict(X_test[move_num:move_num+10])  # Predict for a single sample
direction = predict_direction(model_output[0])
print(f"Predicted direction: {direction}")
print(f"Actual direction: {test_moves[move_num]}")

